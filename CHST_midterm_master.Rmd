---
title: 'Analysis Of Aquatic Invasive Species In Pennsylvania Reveals That Invasion Intensity Is Spatially Unequal But Not Driven By Shifting Human Population Demography'
date: "3/22/2018"
author: Lisa Chemplayil, Nicholas A. Huron, Nicolina G. Sciarretta, Tom Thomas
output: 
  html_document:
    toc: true
    toc_depth: 3
---

##Abstract
Invasive species are an increasingly global problem. The spread of non-native and detrimental species has negative ecological, economic, and social implications for humans, from reduced crop yields to depreciated living conditions. Our goal was to understand the spread of invasive aquatic species across Pennsylvania. We determined that invasive species were unequally distributed, with more found in rural areas in the northwest (often represented by Republicans). Additionally, we found that the relationship between human population growth and new invasions is weak, which may suggest that lack of invasion control in rural areas could play a bigger role than shifting human demography.

```{r setup, results='hide', message=FALSE, echo = FALSE}
#Authors: TT, NGS, NAH

#clear workspace first
rm(list=ls())

knitr::opts_chunk$set(echo = TRUE)
#set the directory
knitr::opts_knit$set(root.dir = "/Volumes/GoogleDrive/My Drive")
#For PCs
#knitr::opts_knit$set(root.dir = "G:/My Drive/")
#for NAH ubuntu
#knitr::opts_knit$set(root.dir = "/home/nicholas/QSGP/")

#load required packages
library(tidyverse)
library(ggmap)
library(RColorBrewer)
library(sp)
library(raster)
library(rgdal)
library(maptools)

#set working directory as needed if the root.dir call fails
#For mac
#setwd("/Volumes/GoogleDrive/My Drive/")
#For PCs
#setwd("G:/My Drive/")
```

##I. Wrangle Invasive Species Records And PA Spatial Data
###Load Data

An initial clean up available invasive and Pennsylvania (PA) spatial datasets was performed after obtaining both datasets. The invasive records (`invasives`) were obtained from the *Pennsylvania iMapInvasives* program ([website](https://www.paimapinvasives.org/)). While all shapefiles (PA spatial data) were loaded, we focused on the 18 **federal congressional districts** as drawn from the 2010 US Census data (`congress`). 

```{r read data, results='hide', message=FALSE, echo = FALSE}
#Authors: TT, NGS, NAH

#Read in invasives dataset and polygon shapefiles

#read in invasives
invasives <- read_csv("./QuantSci_GP/data/PA_Invasive_Species/all_obs_imap_18Dec17_v2_0.csv", progress = FALSE)

#read in shapefiles
town      <-readOGR(dsn = "./QuantSci_GP/data/PA_Invasive_Species/shapefiles", layer='PaMunicipalities2017_01')
s_senate  <- readOGR(dsn = "./QuantSci_GP/data/PA_Invasive_Species/shapefiles", layer='PaSenatorial2017_01')
s_house   <- readOGR(dsn = "./QuantSci_GP/data/PA_Invasive_Species/shapefiles", layer='PaHouse2017_01')
congress  <- readOGR(dsn = "./QuantSci_GP/data/PA_Invasive_Species/shapefiles", layer='PaCongressional2017_01')
county    <- readOGR(dsn = "./QuantSci_GP/data/PA_Invasive_Species/shapefiles", layer='PaCounty2017_01')
```

###Clean Up Data i: Consistent References

Prior to  analyses, we investigated the content of each dataset.

The focal SpatialPolygonsDataFrame object, `congress`, contains information on the 18 districts. The `data` section contains the following columns that are relevant for our analyses:

  1. LEG_DISTRI [factor]: the unique number identifier for each district
  5. PARTY  [factor]: the one letter code for the political party of each district's representative
  
This object also contains a `polygons` section that gives spatial data that helps draw each district. The `ID` identifies each polygon to a district (although it starts counting at zero and connects through the `plotOrder` section). There is also a `bbox` section that defines the plot area and a `proj4string` section that contains the coordinate reference system to translate latitude and longitude values to the plot.

We also use the `invasives` data as the basis for our invasive species observations with the grain of congressional districts. The SpatialPolygonsDataFrame object version of `invasives` (further below as `aqua_invasives_spatial`) contains information on observed invasive species by date and geographic coordinates. The data section contains the following columns that are relevant to our analyses:
  
  1. state_scientific_name [character]: The scientific name of the invasive species
  2. natl_habitat [character]: general category of aquatic or terrestrial species, later used to match species types
  3. speciestype [charcter]: while empty initially, it is populated with general species groups from `imap_spp.csv`
  4. obsdate [character]: the date of observation in the format M/DD/YYYY HH:MM
  5. obscomments_long [character]: comments that help illuminate possible sources of error or uncertainty, used to check dates
  6. obsorigxcoord [double]: the longitude value of the observation (changed to long below)
  7. obsorigycoord [double]: the latitude value of the observation (changed to lat below)
  
The `proj4strings` section translates latitude and longitude values to the plot. There is also data from `coords` (coordinate) and `bbox` (integer value) data.
  1. coords [double]: Maps species observed to a set of coordinates

Dataset evaluation indicated a need for clean up before inferring invasive species results for PA. This involved changing naming convention of some sections (e.g., changing `obsorigxcoord` to `long` for longitude) and ensuring that a consistent *coordinate reference system* (**CRS**) was in place across all datasets.
```{r rename latlong, echo = FALSE, results = 'hide'}
#Authors: TT

colnames(invasives)[colnames(invasives) %in% 'obsorigxcoord'] <- 'long'
colnames(invasives)[colnames(invasives) %in% 'obsorigycoord'] <- 'lat'
```

```{r standardize shapefile CRS, echo = FALSE, results = 'hide'}
#Authors: TT

#standardize the coordinate reference systems for shapefiles.
county <- spTransform(county, CRS('+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0'))
s_senate <- spTransform(s_senate, CRS('+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0'))
congress <- spTransform(congress, CRS('+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0'))
town <- spTransform(town, CRS('+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0'))
s_house <- spTransform(s_house, CRS('+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0'))
```

###Clean Up Data ii: The Spotted Lanternfly

In our communication with colleagues, we learned that the spotted lanternfly (*Lycorma delicatula*) is not tracked reliably in `invasives`.

First, we summarized the data that have common names containing the word `"fly"`, just to make sure nothing was lost in syntax variation.
```{r EDA lantern fly, echo = FALSE}
#Authors: NAH

invasives %>%
  group_by(state_scientific_name, stateCommonName) %>%
  count() %>%
  filter(str_detect(stateCommonName, pattern = "fly")) %>%
  arrange(desc(n)) %>%
  knitr::kable(., col.names = c("Scientific Name", "Common Name", "Number of Observations"))
```

>It is clear that there are a few observations with fly, and it looks like `"Spotted Lanternfly"` is the consistent common name for this species, but we stuck to the scientific name to be certain when we `filter`ed it out in our new `invasives` object (called `invasives2`).

We then removed all observations matching *Lycorma delicatula*, which resulted in the removal of the **6 observations**, leaving us with 9815 total observations.
```{r filter lanternfly, echo = FALSE, results = 'hide'}
#Authors: TT, NAH

#get original row count
nrow(invasives)

invasives2 <- invasives %>%
  filter(state_scientific_name != "Lycorma delicatula")

#check that we lost some rows
nrow(invasives2)
```

###Clean Up Data iii: Reliable Observation Years

We know from previous communications with the *Pennsylvania iMapInvasives* program that the date of observation (`obsdate`) variable contains data that are not all reliable. To be certain that we use dates with reliable years only, we cleaned `obsdate` and then `mutate`ed a new variable (called `year`) that was used for temporal analyses.
```{r clean obsdate, echo = FALSE, results = 'hide'}
#Authors: NAH

#explore obsdate and obscomments_long
invasives2 %>%
  dplyr::select(obsdate, obscomments_long) %>%
  filter(str_detect(obscomments_long, pattern = "(d|D)ate")) %>%
  arrange(obscomments_long)

#get number of rows of interest
invasives2 %>%
  dplyr::select(obsdate, obscomments_long) %>%
  filter(str_detect(obscomments_long, pattern = "(d|D)ate")) %>%
  arrange(obscomments_long) %>%
  nrow()
```

We confirmed that there are 724 rows that contain some reference to the date in the comments section. These likely represent dates that need fixing or removal from the dataset. To locate the true unknowns/uncertains, we first used the keywords `"unknown"` and `"placeholder"`/`"place-holder"`.
```{r find unknowns, echo = FALSE, results = 'hide'}
#Authors: NAH

invasives2 %>%
  dplyr::select(obsid, obscomments_long) %>%
  filter(str_detect(obscomments_long, pattern = "(d|D)ate")) %>%
  filter(str_detect(obscomments_long, pattern = "(u|U)nknown | (p|P)lace[\\-holder]*")) %>%
  arrange(obscomments_long)
```

Of the 724 rows, only **56** had the keywords we are worried about. These rows represent dates that may be slated for removal. The other 668 are likely ambiguous but could be determined to year with confidence. We trimmed the former before verifying the years for `obsdate` values in the latter. We then used `obsid` values as our identifiers for the rows we needed to remove (manually spot-checked the 56 rows).
```{r rm questionable date rows, echo = FALSE, results = 'hide'}
#Authors: NAH

#check the nrows of invasives2 to start
nrow(invasives2)

#object of rows to remove with certainty
rows2rm <- c("PA-6898U", "PA-379U", "PA-8018U", "PA-6643U", "PA-6407U", "PA-6885U",	"PA-6766U", "PA-6891U", "PA-6693U",	"PA-6761U")

#remove these rows from invasives2
invasives2 <- invasives2 %>%
  dplyr::filter(!(obsid %in% rows2rm))

#check that rows were dropped
nrow(invasives2)
```

As it turned out, only 10 of the rows in the 56 lacked a confident year of observation, so we removed them, resulting in 9805 observations. 

However, this was not the end of cleaning `invasives` by `obsdate`. Using `View()` of `invasivescheck` below, we checked that dates are correct in the table by searching for keywords for unreliable daates by eye. In the `obscomments_long` column, the word *representative* was searched, which resulted in 110 entries. Of those 110 entries about half are dated in `obsdate` as 1980. However, in `obscomments_long`, it states that `"1980 is a repesentative of the time frame (1980-2007) when this county was known to begin hosting HWA"`, indicating a clear problem of reliable **year**. The next word searched was *unknown*, which produced 31 entries, 13 of which conclude that the exact day/month is not known but the year is. The last search word was *known*, this also brought up *unknown* again. *known* had 218 entries, 50 of which referred to the "representative" word, and more than half indicate unknown day/month but known year.
```{r check years, eval = FALSE, echo = FALSE, results = 'hide'}
#Authors: NGS

View(invasivescheck <- invasives2 %>% dplyr::mutate(year = str_extract(obsdate, "\\d{4}")) %>% 
  dplyr::select(obsid, stateCommonName, obsdate, obscomments_long, year))

```

According to these observations the years do match the comments, but the aforementioned `1980-2007` dates required removal. This whittled down `invasives2` to **9756** observations.
```{r remove representative, echo = FALSE, results = 'hide'}
#Authors: NAH

#filter out the observations with the 1980-2007 date range. This can be done with a match of "representative", but when observing the filtration of View(), there are some other unintended rows that are fine for dates. Instead, let's filter with that date range in the comments, "1980-2007" as well!
(rows2rm2 <- invasives2 %>%
  dplyr::select(obsid, obscomments_long) %>%
  filter(str_detect(obscomments_long, pattern = "(r|R)epresentative")) %>%
  filter(str_detect(obscomments_long, pattern = "1980\\-2007")) %>%
  arrange(obscomments_long) %>%
  dplyr::select(obsid))

rows2rm2 <- as_vector(rows2rm2)

#invasives2 row check
nrow(invasives2)

#remove these rows from invasives2
invasives2 <- invasives2 %>%
  dplyr::filter(!(obsid %in% rows2rm2))

#final row check in invasives2
nrow(invasives2)

```

We then created the new `year` column for temporal analyses, thereby resolving `obsdate` inconsistencies and permitting us to begin exploring the data.
```{r mutate years, echo = FALSE, results = 'hide'}
#Authors: NAH

invasives2 <- invasives2 %>%
  dplyr::mutate(year = str_extract(obsdate, "\\d{4}"))
```

##II. EDA - Univariate  
###Identify Focal Species

We began our exploratory data analysis (**EDA**) by reading in the `iMap_spp.csv` file to a new object `imap_spp`. We trimmed the new object down to all entries we already tidied by selectively joining `imap_spp` to `invasives2` by `"state_scientific_name", "stateCommonName", and "natlhabitat"`. The resulting object is `invasives3`, which was filtered even further to contain focal species below. 
```{r read in imap_spp and join, echo = FALSE, results = 'hide', message = FALSE}
#Authors: NAH

#read in imap_spp
imap_spp <- read_csv("./QuantSci_GP/data/PA_Invasive_Species/iMap_sppp.csv")
#change the colname to match invasives2
colnames(imap_spp)[colnames(imap_spp) %in% "SpeciesType"] <- "speciestype"

#left join to invasives2 to make new object, invasives3
invasives3 <- left_join(x = invasives2, y = imap_spp, by = c("state_scientific_name", "stateCommonName", "natlhabitat"))

#now we need to drop the invasives2 version of speciestype and rename speciestype.y to speciestype
invasives3 <- invasives3 %>%
  dplyr::select(-speciestype.x, speciestype = speciestype.y)

invasives3

```

Data exploration was done to select focal taxa. Full disclosure, an exploration of this summary was done previously, leading to the use of aquatic species, as they are taxonomically diverse and less biased towards overwhelming **plant** observations. The final filtered version of just **aquatic invasive species** is called `aqua_invasives`, which contained **3012** observations.
```{r look at aquatic v terrestrial and then filter, echo = FALSE, results = 'hide', message = FALSE}
#Authors: NAH

imap_spp %>%
  #filter(state_scientific_name %in% as_vector((invasives3 %>% distinct(state_scientific_name)))) %>%
  filter(state_scientific_name %in% unique(invasives3$state_scientific_name)) %>%
  group_by(natlhabitat) %>%
  count()
imap_spp %>%
  filter(state_scientific_name %in% unique(invasives3$state_scientific_name)) %>%
  group_by(natlhabitat, speciestype) %>%
  count() %>%
  arrange(desc(n))

#filter for natlhabitat == "aquatic"
(aqua_invasives <- invasives3 %>%
  filter(natlhabitat == "aquatic" | natlhabitat == "Aquatic"))

```

>It is easy to see that working with aquatic species may involve fewer species, but the involved species are separated by group more evenly (not 201 of 209 as plants, as in terrestrial species).


We also needed to make the `aqua_invasives` object a SpatialPolygonsDataFrame and set the CRS for that as well, having finished tidying it. To make this easier, we created a new object, `aqua_invasives_spatial`.
```{r convert invasives, echo = FALSE, results = 'hide'}
#Authors: TT, NAH

aqua_invasives_spatial <- aqua_invasives

coordinates(aqua_invasives_spatial) <- ~long+lat
proj4string(aqua_invasives_spatial) <- projection('+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0')
```


###Species Richeness Per Federal Congressional
In an effort to understand how invasive species are spread across PA, we investigated invasive species richness (SR) for each of the congressional districts on a state map.

```{r join SR and congressional data, echo = FALSE, results = 'hide'}
#Authors: NGS

srPerCongressional <- over(aqua_invasives_spatial, congress)
srPerCongressional <- cbind(srPerCongressional, aqua_invasives_spatial$state_scientific_name)
colnames(srPerCongressional)[colnames(srPerCongressional) %in% 'aqua_invasives_spatial$state_scientific_name'] <- 'species' 
srPerCongressional <- group_by(srPerCongressional, LEG_DISTRI) 
srPerCongressional <- dplyr::summarise(srPerCongressional, sr=length(unique(species)))
```

```{r plot the results, message = FALSE, warning = FALSE, echo = FALSE} 
#Authors: NGS

invasivesCongressional <- congress
invasivesCongressional@data <- left_join(invasivesCongressional@data, srPerCongressional, by='LEG_DISTRI') 

#fix the data type of for R.linux (this snippet by NAH)
if(Sys.info()["sysname"]=="Linux"){
  invasivesCongressional@data$LEG_DISTRI <- as.character(invasivesCongressional@data$LEG_DISTRI)
}

invasivesCongressionalgg <- fortify(invasivesCongressional, region='LEG_DISTRI') 
invasivesCongressionalgg <- left_join(invasivesCongressionalgg, invasivesCongressional@data, by=c('id' = "LEG_DISTRI")) 

p <- ggplot(data=invasivesCongressionalgg)+
  geom_polygon(aes(x=long, y=lat, group=group, fill=sr))+ 
  coord_fixed(1.3)+ 
  scale_fill_gradient() +
  ggtitle(str_to_title("Species Richness of Invasive Aquatic Species In Pennsylvania")) +
    labs(y = "Latitude of PA in Degrees", x = "Longitute of PA in Degrees")

p
```

Additionally, we broke down aquatic invasive species richness by congression LEG_DISTRI for the five major species types in the dataset as well.
```{r split by species type, echo = FALSE, message = FALSE, warning = FALSE, results = 'hide'}
#Authors: NGS, NAH

turtles <- aqua_invasives %>% filter(speciestype == "turtle")
plants <- aqua_invasives %>% filter(speciestype == "plant")
arthropods <- aqua_invasives %>% filter(speciestype == "arthropod")
mollusc <- aqua_invasives %>% filter(speciestype == "mollusc")
fish <- aqua_invasives %>% filter(speciestype == "fish")

#combine into a list for easy looping
byspeciestype <- list(turtles, plants, arthropods, mollusc, fish)
names(byspeciestype) <- c("turtles", "plants", "arthropods", "mollusc", "fish")
```

Now that we have filtered versions of `aqua_invasives` for each `speciestype`, we needed to turn them into **SpatialPolygonsDataFrames** and calculate **Species Richness (SR)**. In summarizing the **SR** for each `speciestype`, we need to populate counties that are missing in the output with **SR** set to zero. This is done mid-loop, check the code comments for further details.

```{r loop get SR by LEG_DISTRI, message = FALSE, echo = FALSE, results = 'hide', warning = FALSE}
#Authors: NGS, NAH

#create new version of list that contains each species type
spatial_byspeciestype <- byspeciestype

#loop to set the coordinate system and reference system
for(a in seq_along(spatial_byspeciestype)){
  coordinates(spatial_byspeciestype[[a]]) <- ~long+lat
  proj4string(spatial_byspeciestype[[a]]) <- projection('+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0')
}

#next, we need to perform a similar loop to overlay the spatial invasives data with the congressional LEG_DISTRI data. we will also end up summarising SR by LEG_DISTRI for each group in this loop.

#initialize holder lists for loops  
sr_per_congressional_byspeciestype <- spatial_byspeciestype
invasive_congressional_byspeciestype <- spatial_byspeciestype
invasive_congressional_gg_byspeciestype <- spatial_byspeciestype
  
for(b in seq_along(spatial_byspeciestype)){
  sr_per_congressional_byspeciestype[[b]] <- over(spatial_byspeciestype[[b]], congress)
  sr_per_congressional_byspeciestype[[b]] <- cbind(sr_per_congressional_byspeciestype[[b]], spatial_byspeciestype[[b]]$state_scientific_name)
  colnames(sr_per_congressional_byspeciestype[[b]])[colnames(sr_per_congressional_byspeciestype[[b]]) %in% 'spatial_byspeciestype[[b]]$state_scientific_name'] <- 'species'
  sr_per_congressional_byspeciestype[[b]] <- group_by(sr_per_congressional_byspeciestype[[b]], LEG_DISTRI)
  sr_per_congressional_byspeciestype[[b]] <- dplyr::summarise(sr_per_congressional_byspeciestype[[b]], sr=length(unique(species))) %>% 
    filter(!is.na(LEG_DISTRI))
  
#we need to add code here that adds the missing districts with SR==0
if(length(setdiff(congress$LEG_DISTRI, sr_per_congressional_byspeciestype[[b]]$LEG_DISTRI)) > 0){
sr_per_congressional_byspeciestype[[b]] <- add_row(sr_per_congressional_byspeciestype[[b]], LEG_DISTRI = setdiff(congress$LEG_DISTRI, sr_per_congressional_byspeciestype[[b]]$LEG_DISTRI), sr = rep(0, length(setdiff(congress$LEG_DISTRI, sr_per_congressional_byspeciestype[[b]]$LEG_DISTRI))))
}
  
  invasive_congressional_byspeciestype[[b]] <- congress
  invasive_congressional_byspeciestype[[b]]@data <- left_join(invasive_congressional_byspeciestype[[b]]@data, sr_per_congressional_byspeciestype[[b]], by = "LEG_DISTRI")
  
#fix the data type of for R.linux (this snippet by NAH)
if(Sys.info()["sysname"]=="Linux"){
  invasive_congressional_byspeciestype[[b]]@data$LEG_DISTRI <- as.character(invasive_congressional_byspeciestype[[b]]@data$LEG_DISTRI)
}

  invasive_congressional_gg_byspeciestype[[b]] <- fortify(invasive_congressional_byspeciestype[[b]], sr_per_congressional_byspeciestype[[b]], region = 'LEG_DISTRI')
  invasive_congressional_gg_byspeciestype[[b]] <- left_join(invasive_congressional_gg_byspeciestype[[b]], invasive_congressional_byspeciestype[[b]]@data, by = c("id" = 'LEG_DISTRI'))
}

```

The result is an object, `invasive_congressional_gg_byspeciestype`, that is formatted to plot the map of results for each species.

```{r loop to plot by group, echo = FALSE} 
#Authors: NGS, NAH

#loop through ggplot commands
for(c in seq_along(invasive_congressional_gg_byspeciestype)){
   print(
    ggplot(data = invasive_congressional_gg_byspeciestype[[c]]) +
    geom_polygon(aes(x=long, y=lat, group=group, fill=sr))+ 
    coord_fixed(1.3)+ 
    scale_fill_gradient()+
    ggtitle(str_to_title(paste0("Species Richness of Invasive Aquatic ", names(invasive_congressional_gg_byspeciestype)[c], " in Pennsylvania"))) +
    labs(y = "Latitude of PA in Degrees", x = "Longitute of PA in Degrees")
   )
}

```

In some congressional districts, there was a higher species richness of our aquatic groups than in other areas. In particular, District 3 consistently remains the area with the highest species richness of aquatic invasive species regardless of species group analyzed. 

###Univariate Distributions Of Richness For Each Grain And Group

To compare species richness between grains, we needed to develop a version of the code for `congress` and `aqua_invasives` for all other grain types. Before we did that, we plotted the univariate curve of SR for `congress`.

```{r plot sr curve congress, echo = FALSE}
#Authors: NAH

ggplot(data = srPerCongressional) +
  geom_density(aes(sr), fill = "black") +
  ggtitle(str_to_title(paste0("Species Richness of Invasive Aquatic Species Across Pennsylvania"))) +
  labs(y = "Density", x = "Species Richness")
```

After confirming a type of plot, we proceeded to repeat the process, but with iteration to gather all `grains` and all `speciestype`s, respectively.
```{r get SR per grain, echo = FALSE, results = 'hide'}
#Authors: NAH

#town    MUNICPAL_
#s_senate LEG_DISTRI
#s_house LEG_DISTRI
#congress LEG_DISTRI
#county  COUNTY_NAM

#initialize a bunch of lists to hold  results
sr_per_grain <- list(NULL, NULL, NULL, NULL, NULL)
grains <- list(town, s_senate, s_house, congress, county)
names(grains) <- c("town", "s_senate", "s_house", "congress", "county")
names(sr_per_grain) <- names(grains)


#we can loop for the three grains with LEG_DISTRI (We will need to manual entry for the other two after that)
for(d in seq_along(sr_per_grain)[2:4]){
  sr_per_grain[[d]] <- over(aqua_invasives_spatial, grains[[d]])
  sr_per_grain[[d]] <- cbind(sr_per_grain[[d]], aqua_invasives_spatial$state_scientific_name)
  colnames(sr_per_grain[[d]])[colnames(sr_per_grain[[d]]) %in% 'aqua_invasives_spatial$state_scientific_name'] <- 'species'
  sr_per_grain[[d]] <- group_by(sr_per_grain[[d]], LEG_DISTRI)
  sr_per_grain[[d]] <- dplyr::summarise(sr_per_grain[[d]], sr=length(unique(species)))
}

#manual for town
  sr_per_grain[[1]] <- over(aqua_invasives_spatial, grains[[1]])
  sr_per_grain[[1]] <- cbind(sr_per_grain[[1]], aqua_invasives_spatial$state_scientific_name)
  colnames(sr_per_grain[[1]])[colnames(sr_per_grain[[1]]) %in% 'aqua_invasives_spatial$state_scientific_name'] <- 'species'
  sr_per_grain[[1]] <- group_by(sr_per_grain[[1]], MUNICIPAL_)
  sr_per_grain[[1]] <- dplyr::summarise(sr_per_grain[[1]], sr=length(unique(species)))

#manual for county
  sr_per_grain[[5]] <- over(aqua_invasives_spatial, grains[[5]])
  sr_per_grain[[5]] <- cbind(sr_per_grain[[5]], aqua_invasives_spatial$state_scientific_name)
  colnames(sr_per_grain[[5]])[colnames(sr_per_grain[[5]]) %in% 'aqua_invasives_spatial$state_scientific_name'] <- 'species'
  sr_per_grain[[5]] <- group_by(sr_per_grain[[5]], COUNTY_NUM)
  sr_per_grain[[5]] <- dplyr::summarise(sr_per_grain[[5]], sr=length(unique(species)))
  
```

First, we evaluated the distribution of species richness by grain.
```{r plot sr curve grains, echo = FALSE}
#Authors: NAH

#plot the curves together
ggplot() +
  geom_density(data = sr_per_grain[[1]], aes(sr, fill = names(sr_per_grain)[1]), alpha = 0.5) +
  geom_density(data = sr_per_grain[[2]], aes(sr, fill = names(sr_per_grain)[2]), alpha = 0.5) +
  geom_density(data = sr_per_grain[[3]], aes(sr, fill = names(sr_per_grain)[3]), alpha = 0.5) +
  geom_density(data = sr_per_grain[[4]], aes(sr, fill = names(sr_per_grain)[4]), alpha = 0.5) +
  geom_density(data = sr_per_grain[[5]], aes(sr, fill = names(sr_per_grain)[5]), alpha = 0.5) +
  ggtitle(str_to_title(paste0("Species Richness Of Invasive Aquatic Species By Grain"))) +
  labs(y = "Density", x = "Species Richness") +
  scale_fill_manual(name = "Grain", values = c("red", "blue", "green", "orange", "black"), labels = c("congress", "county", "s_house", "s_senate", "town"), guide = 'legend')
```

In looking at each of the grains, it is clear that there are differences in SR by grain. While the means of the distributions appear to cluster around 0--10 (estimated visually), none overlap perfectly. Some appear shifted slightly relative to the rest (e.g., congress is shifted right of state house). Notably, there appear to be several outliers per group, located in the right tail (higher values for species richness). These higher values range from 15--20 species.

We repeated the process for different `speciestype`s for the `congress` grain. Note that the object `sr_per_congressional_byspeciestype` contains all of the data we need to make the comparison! We simply need to create a similar plot to the one for grains above.

```{r plot SR per speciestype in congress, echo = FALSE}
#Authors: NAH

#plot the curves together
ggplot() +
  geom_density(data = sr_per_congressional_byspeciestype[[1]], aes(sr, fill = names(sr_per_congressional_byspeciestype)[1]), alpha = 0.5) +
  geom_density(data = sr_per_congressional_byspeciestype[[2]], aes(sr, fill = names(sr_per_congressional_byspeciestype)[2]), alpha = 0.5) +
  geom_density(data = sr_per_congressional_byspeciestype[[3]], aes(sr, fill = names(sr_per_congressional_byspeciestype)[3]), alpha = 0.5) +
  geom_density(data = sr_per_congressional_byspeciestype[[4]], aes(sr, fill = names(sr_per_congressional_byspeciestype)[4]), alpha = 0.5) +
  geom_density(data = sr_per_congressional_byspeciestype[[5]], aes(sr, fill = names(sr_per_congressional_byspeciestype)[5]), alpha = 0.5) +
  ggtitle(str_to_title(paste0("Species Richness Of Invasive Aquatic Species By Species Type"))) +
  labs(y = "Density", x = "Species Richness") +
  scale_fill_manual(name = "Species Type", values = c("red", "blue", "green", "orange", "black"), labels = c("arthropods", "fish", "mollusc", "plants", "turtles"), guide = 'legend')
  
```

Looking among species types, we do see several groups that almost approximate normal distributions (namely `plants` and `mollusc`). The rest appear to be multimodal, with some cases of `SR == 0` and at least one case of `SR > 0`. Notably, the two `speciestype`s that are closest to normal distribution shape also have the most instances of high species richness. As for outliers, `fish` appears to have the only distinct outlier to the right of the main distribution.

For both `grain` and `speciestype`, it is clear that distributions are not exactly normal, so it was worth exploring data transformation. In an effort to normalize these data, a well-known and standard transformation, a **natural log** transformation, was explored, since it tightens some of the wider distributions typically. Since we have values of `0` for species richness in some places, we added `1` to each `SR` value before transformation to avoid undefined results.

```{r plot log transform grains, echo = FALSE}
#Authors: NAH

ggplot() +
  geom_density(data = sr_per_grain[[1]], aes(log(sr+1), fill = names(sr_per_grain)[1]), alpha = 0.5) +
  geom_density(data = sr_per_grain[[2]], aes(log(sr+1), fill = names(sr_per_grain)[2]), alpha = 0.5) +
  geom_density(data = sr_per_grain[[3]], aes(log(sr+1), fill = names(sr_per_grain)[3]), alpha = 0.5) +
  geom_density(data = sr_per_grain[[4]], aes(log(sr+1), fill = names(sr_per_grain)[4]), alpha = 0.5) +
  geom_density(data = sr_per_grain[[5]], aes(log(sr+1), fill = names(sr_per_grain)[5]), alpha = 0.5) +
  ggtitle(str_to_title(paste0("Transformed Species Richness Of Invasive Aquatic Species By Grain"))) +
  labs(y = "Density", x = "ln(Species Richness + 1)") +
  scale_fill_manual(name = "Grain", values = c("red", "blue", "green", "orange", "black"), labels = c("congress", "county", "s_house", "s_senate", "town"), guide = 'legend')
```

```{r plot log transform speciestype, echo = FALSE}
#Authors: NAH

ggplot() +
  geom_density(data = sr_per_congressional_byspeciestype[[1]], aes(log(sr+1), fill = names(sr_per_congressional_byspeciestype)[1]), alpha = 0.5) +
  geom_density(data = sr_per_congressional_byspeciestype[[2]], aes(log(sr+1), fill = names(sr_per_congressional_byspeciestype)[2]), alpha = 0.5) +
  geom_density(data = sr_per_congressional_byspeciestype[[3]], aes(log(sr+1), fill = names(sr_per_congressional_byspeciestype)[3]), alpha = 0.5) +
  geom_density(data = sr_per_congressional_byspeciestype[[4]], aes(log(sr+1), fill = names(sr_per_congressional_byspeciestype)[4]), alpha = 0.5) +
  geom_density(data = sr_per_congressional_byspeciestype[[5]], aes(log(sr+1), fill = names(sr_per_congressional_byspeciestype)[5]), alpha = 0.5) +
  ggtitle(str_to_title(paste0("Transformed Species Richness Of Invasive Aquatic Species By Species Type"))) +
  labs(y = "Density", x = "ln(Species Richness + 1)") +
  scale_fill_manual(name = "Species Type", values = c("red", "blue", "green", "orange", "black"), labels = c("arthropods", "fish", "mollusc", "plants", "turtles"), guide = 'legend')

```

In both cases, it does appear like normality may be improved in some cases, howeve this was not the case for all groupings (`s_house`, `county`, and `town` for `grain` and `mollusc` for `speciestype` in particular). Additionally, outliers appear to be less severe, but still exist. A **Shapiro-Wilk Normality Test** can help evaluation between untransformed and transformed data. With a loop, it was easy enough to produce a before/after table:

```{r shapiro tests, echo = FALSE}
#Authors: NAH

swtest_grains <- tibble(untransformed.w = NA, untransformed.p = NA, logtransformed.w = NA, logtransformed.p = NA)
for(e in seq_along(sr_per_grain)){
  compare_holder <- c(NA, NA, NA, NA)
  names(compare_holder) <- c("untransformed.w", "untransformed.p", "logtransformed.w", "logtransformed.p")
  compare_holder[1] <- shapiro.test(sr_per_grain[[e]]$sr)$statistic
  compare_holder[2] <- shapiro.test(sr_per_grain[[e]]$sr)$p.value
  compare_holder[3] <- shapiro.test(log((sr_per_grain[[e]]$sr+1)))$statistic
  compare_holder[4] <- shapiro.test(log((sr_per_grain[[e]]$sr+1)))$p.value
  swtest_grains <- bind_rows(swtest_grains, compare_holder)
swtest_grains <- swtest_grains %>% filter(complete.cases(.)) %>% round(., 3)
}

(swtest_grains <- knitr::kable(as_tibble(cbind(grain = names(sr_per_grain), swtest_grains))))

swtest_speciestype <- tibble(untransformed.w = NA, untransformed.p = NA, logtransformed.w = NA, logtransformed.p = NA)
for(e in seq_along(sr_per_congressional_byspeciestype)){
  compare_holder <- c(NA, NA, NA, NA)
  names(compare_holder) <- c("untransformed.w", "untransformed.p", "logtransformed.w", "logtransformed.p")
  compare_holder[1] <- shapiro.test(sr_per_congressional_byspeciestype[[e]]$sr)$statistic
  compare_holder[2] <- shapiro.test(sr_per_congressional_byspeciestype[[e]]$sr)$p.value
  compare_holder[3] <- shapiro.test(log((sr_per_congressional_byspeciestype[[e]]$sr+1)))$statistic
  compare_holder[4] <- shapiro.test(log((sr_per_congressional_byspeciestype[[e]]$sr+1)))$p.value
  swtest_speciestype <- bind_rows(swtest_speciestype, compare_holder)
swtest_speciestype <- swtest_speciestype %>% filter(complete.cases(.)) %>% round(., 3)
}

(swtest_speciestype <- knitr::kable(as_tibble(cbind(speciestype = names(sr_per_congressional_byspeciestype), swtest_speciestype))))
```

In reviewing these tables, it is clear that no untransformed distribution for `grain` was normal (p-value < 0.05), but the transformation did improve normality across the board, with only `s_senate` becoming truly normal according to this test. This improvement of normality was not the case for `speciestype` plots, which had mixed transformation results. Initially, both `plants` and `mollusc` were normal according to Shapiro-Wilk values, but the transformed `mollusc` distribution was not. `Turtles` did not change, but this was an expected result, as the only species richness values in this group are binary (only one species, values of `0` or `1`). The remaining two distributions did improve, but not enough to be considered normal.

Upon reviewing the previous figures, it is evident that there a number of outliers associated with NW Pennsylvania, specifically **District 3/Erie County**. There are a disproportionate number of aquatic **plant** and **fish** species in these areas, which appear to contribute to the visible outliers on the right side of many of the distributions.

##III. EDA - Multivariate Covariation
###Which political party represents areas with more invasive species? If you find a difference, what is a possible explanation?

```{r plot d vs r, echo = FALSE}
#Authors: NGS

#To compare republican areas to democratic areas we used species richness as our marker.
#Filtering to just D in aquatic invasives. 
Dem_aqua_invasives <- invasivesCongressionalgg %>% filter(PARTY == "D")

#In order to use a color gradient from blue to red we have to reverse the sign of species richness for one of the parties. In this case we reversed the sign for the Democratic party for species richness.
Dem_aqua_invasives <- Dem_aqua_invasives %>% mutate(sr * (-1))

#Renaming the -sr column.
colnames(Dem_aqua_invasives)[colnames(Dem_aqua_invasives)=="sr * (-1)"] <- "Reversing the Sign"

#Removing the extra sr column from the democratic party table.
Dem_aqua_invasives$sr <- NULL

#Renaming the sr column back to its orginal name for easy mapping. 
colnames(Dem_aqua_invasives)[colnames(Dem_aqua_invasives) =="Reversing the Sign"] <- "sr"

#Filtering to just R in aquatic invasives.
Rep_aqua_invasives <- invasivesCongressionalgg %>% filter(PARTY =="R")


#Creating the map for Democrat v. Republican invasives species richness.. 
DR_invasives <- ggplot(data = Rep_aqua_invasives)+
  geom_polygon(aes(x=long, y=lat, group=group, fill=sr))+ 
  coord_fixed(1.3) +
  geom_polygon(data = Dem_aqua_invasives, aes(x=long, y=lat, group=group, fill=sr))+
  scale_fill_gradient2(name = "", low = "#000066", mid = "#FFFFFF", high = "#FF0000", midpoint = 0, labels = c("High SR Republican", "High SR Democrat"), breaks = c(32, -8))+
  labs(y = "Latitude of PA in Degrees", x = "Longitude of PA in Degrees", title = "Invasive Species Richness\nBy Federal Congressional District And Political Party")

DR_invasives

#Since the species richness in democratic areas is significantly lower than republican areas the color gradient shades in with red rather then blue and therefore gives us a purple color for the democratic areas. So to reiterate, Republican areas are represented in shades of red and the Democratic areas are represented in light purple/white.
```

Based on our findings of the species richness of our political parties map, we can deduct that **Republican** areas tend to have a higher species richness of invasive species than Democratic ones. There are many factors that could contribute to this relationship. For example, the fact that as of the most recent presidential election, Pennsylvania is slightly more red than blue based on the election results. Thus, there are inherently more Republican areas. Additionally, Republican areas are mostly rural, which may be an ideal environment for invasive species to spread. 

By definition an **invasive species** is a species that is usually non-native that becomes established in a new area and spreads without further human intervention beyond its point of initial release. Several stages must be completed for a species to be formally recognized as invasive. First, it has to be introduced to an area, then it must colonize, after which it has establish itself by reproducing, and finally it has to spread. Once it spreads, it is now an **invasive species**. To be specific, one of the Republican areas with the highest species richness of invasive species is Erie County (District 3, NW PA). Erie County is bordered by one of the great lakes, Lake Erie which can be used as a route for aquatic invasive species to thrive and spread.  On the contrary, the lower species richness of invasive species corresponds to the Democratic areas, one of which is Philadelphia County which is an urban area, which may be a less suitable environment for invasive aquatic species to be introduced, colonize, establish themselves, and ultimately spread. 

###Does the rate of human population growth correlate to the rate of species invasions?

To understand the relationship between human populations and invasive species invasions, we needed to read in census data, which spanned 2000--2010 for Pennsylvania. This dataset was filtered to `county` and was then joined with species richness levels for 2000 and 2010, cumulatively and respectively.

```{r read in census data, results = 'hide', message = FALSE, warning = FALSE, echo = FALSE}
#Authors: NAH

census <- read_csv("./QSGP_CHST/pa_census.csv", skip = 6) 
census <- census %>%
  dplyr::select(`2010 State, County & Munic. FIPS Code`:`Change_2000_2010`) #%>%
  #dplyr::select(`2010 State, County & Munic. FIPS Code`, `Geographic Area`, Number_2000, Number_2010, Change_2000_2010)
```

```{r calculate pop growth rate, echo = FALSE, results = 'hide'}
#Authors: NAH

census <- census %>%
  mutate(growth_rate = ((Number_2010 - Number_2000)/Number_2000))
knitr::kable(census, align = "l")
```

```{r cum SR by county 2000, echo = FALSE}
#Authors: NAH

#by 2000
aqua_2000 <- aqua_invasives %>%
  filter(year <= 2000)
aqua_spatial_2000 <- aqua_2000
coordinates(aqua_spatial_2000) <- ~long+lat
proj4string(aqua_spatial_2000) <- projection('+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0')

srPerCounty2000 <- over(aqua_spatial_2000, county)
srPerCounty2000 <- cbind(srPerCounty2000, aqua_spatial_2000$state_scientific_name)
colnames(srPerCounty2000)[colnames(srPerCounty2000) %in% 'aqua_spatial_2000$state_scientific_name'] <- 'species' 
srPerCounty2000 <- group_by(srPerCounty2000, COUNTY_NAM) 
srPerCounty2000 <- dplyr::summarise(srPerCounty2000, sr=length(unique(species)))

#by 2010
aqua_2010 <- aqua_invasives %>%
  filter(year <= 2010)
aqua_spatial_2010 <- aqua_2010
coordinates(aqua_spatial_2010) <- ~long+lat
proj4string(aqua_spatial_2010) <- projection('+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0')

srPerCounty2010 <- over(aqua_spatial_2010, county)
srPerCounty2010 <- cbind(srPerCounty2010, aqua_spatial_2010$state_scientific_name)
colnames(srPerCounty2010)[colnames(srPerCounty2010) %in% 'aqua_spatial_2010$state_scientific_name'] <- 'species' 
srPerCounty2010 <- group_by(srPerCounty2010, COUNTY_NAM) 
srPerCounty2010 <- dplyr::summarise(srPerCounty2010, sr=length(unique(species)))
```


```{r join 2000_2010 and make rate col, echo = FALSE, results = 'hide'}
#Authors: NAH

#now join them by COUNTY_NAM
srPerCounty2000_2010 <- inner_join(srPerCounty2000, srPerCounty2010, by = "COUNTY_NAM", suffix = c("_2000", "_2010"))

#mutate a new rate column
srPerCounty2000_2010 <- srPerCounty2000_2010 %>%
  mutate(sr_change_2000_2010 = (sr_2010 - sr_2000),
         sr_rate = ((sr_2010 - sr_2000)/sr_2000)
         )

knitr::kable(srPerCounty2000_2010)
```

```{r filter census to counties, echo = FALSE, warning = FALSE}
#Authors: NAH

census_county <- census %>%
  filter(str_detect(string = `Geographic Area`, pattern = "(c|C)ounty")) %>%
  mutate(`Geographic Area` = str_remove(string = `Geographic Area`, pattern = "\\s(c|C)ounty")) %>%
  mutate(`Geographic Area` = toupper(`Geographic Area`))

#now left join by the SR object for 2000_2010
sr_pop_2000_2010 <- left_join(srPerCounty2000_2010, census_county, by = c('COUNTY_NAM' = "Geographic Area")) %>%
  filter(!is.na(COUNTY_NAM))
knitr::kable(sr_pop_2000_2010)
```

We then calculated the correlation between (Pearson's product-moment) and plotted the population growth and species richness growth, both calculated as raw change in numbers and the proportional change. Please note that the data points for each plot were spaced slightly to show where some points clustered on one another.

```{r plot pop vs sr, echo = FALSE}
#Authors: NAH

p_sr_pop <- ggplot(data = sr_pop_2000_2010, mapping = aes(x = Change_2000_2010, y = sr_change_2000_2010)) +
  geom_point(position = position_jitter(w = 5, h = 0)) +
  labs(x = "Population Growth (Number Of New Individuals)", y = "Species Richness Growth (Number of New Species)") +
  ggtitle("Covariation Between Absolute Population Growth \nand Aquatic Invasive Species Richness Growth in Pennsylvania")

p_sr_pop_prop <- ggplot(data = sr_pop_2000_2010, mapping = aes(x = growth_rate, y = sr_rate)) +
  geom_point(position = position_jitter(w = 0.01, h = 0)) +
  labs(x = "Proportional Population Growth Rate", y = "Proportional Species Richness Growth Rate") +
  ggtitle("Covariation Between Proportional Population Growth \nand Aquatic Invasive Species Richness Growth in Pennsylvania")
```

```{r fit a model, echo = FALSE, warning = FALSE}
#Authors: NAH

#add to plot (use geom_smooth for pretty confidence interval)
#p_sr_pop + geom_abline(aes(intercept = lm_sr_pop[[1]][1], slope = lm_sr_pop[[1]][2]), color = "blue")
p_sr_pop + geom_smooth(method = "lm")
#test correlation and make model for prop
cor.test(x = sr_pop_2000_2010$Change_2000_2010, y = sr_pop_2000_2010$sr_change_2000_2010)
lm_sr_pop <- lm(formula = sr_change_2000_2010~Change_2000_2010, data = sr_pop_2000_2010)

#add to plot (use geom_smooth for pretty confidence interval)
#p_sr_pop_prop + geom_abline(aes(intercept = lm_sr_pop_prop[[1]][1], slope = lm_sr_pop_prop[[1]][2]), color = "blue")
p_sr_pop_prop + geom_smooth(method = "lm")
#test correlation and make model for prop
cor.test(x = sr_pop_2000_2010$growth_rate, y = sr_pop_2000_2010$sr_rate)
lm_sr_pop_prop <- lm(formula = sr_rate~growth_rate, data = sr_pop_2000_2010)


```

In both cases, the correlation was positive but not strong enough to be significant. This suggests that there may be some sort of relationship, but it is not best explained by covariance between human population growth rates and species richness growth rates. The lack of points that fall within (or close to) the confidence interval bands (grey) around the modeled line (blue) support this claim.

In an effort to find evidence of a clear relationship between human demography and invasive species richness, we also evaluated the relationship between the human population in 2010 and invasive species richness in 2010 as well (please note that we log-transformed both values to normalize and standardize both datasets for comparison but did also run the correlation test with untransformed data as well). Further, we looked at the percentage of Pennsylvania state total population and invasive species richness for 2010.

```{r look at correlation of present pop, echo = FALSE}
#Authors: NAH

#2010 populations and 2010 SR
ggplot(data = sr_pop_2000_2010, mapping = aes(x = log(sr_pop_2000_2010$Number_2010), y = log(sr_pop_2000_2010$sr_2010))) +
  geom_point(position = position_jitter(w = .1, h = 0)) +
  geom_smooth(method = "lm") +
  labs(x = "Log-Transformed 2010 County Populations", y = "Log-Transformed 2010 Species Richness By County") +
  ggtitle("Covariation Between Pennsylvania County Populations \nand Aquatic Invasive Species Richness in 2010")

#correlation test untransformed
cor.test(x = (sr_pop_2000_2010$Number_2010), y = (sr_pop_2000_2010$sr_2010))

#correlation test log transformed
cor.test(x = log(sr_pop_2000_2010$Number_2010), y = log(sr_pop_2000_2010$sr_2010))

#2010 relative percentage of state and 2010 SR
#need to mutate Percent Share of State Total 2010 to proportion
sr_pop_2000_2010 <- sr_pop_2000_2010 %>%
  mutate(`Percent Share of State Total 2010` = (as.numeric(str_remove(`Percent Share of State Total 2010`, "%")))/100)
#plot
ggplot(data = sr_pop_2000_2010, mapping = aes(x = sr_pop_2000_2010$`Percent Share of State Total 2010`, y = sr_pop_2000_2010$sr_2010)) +
  geom_point(position = position_jitter(w = .001, h = 0)) +
  geom_smooth(method = "lm") +
  labs(x = "2010 Proportion of Total Population By County", y = "2010 Species Richness By County") +
  ggtitle("Covariation Between Proportion of Pennsylvania Population By County \nand Aquatic Invasive Species Richness in 2010")

#check correlation
cor.test(x = sr_pop_2000_2010$`Percent Share of State Total 2010`, y = sr_pop_2000_2010$sr_2010)
```

These relationships were also investigated with the Pearson product-moment correlation, which did not return significant correlations for either pair of untransformed data. However, both of these relationships are positive and are stronger than human population growth rate. Moreover, the transformed 2010 population and invasive species richness variables are significantly correlated with each other, which may support the results that indicate rural areas of Pennsylvania have the highest invasive species richness (in the previous section). However, it may be worth exploring further as new datasets become available (e.g., 2020 census data) to confirm this pattern.

###What are the interesting patterns of covariation among the species and species groups? Are the correlations significant?

To help visualize the relationship between `species` and `speciestype`, we used the `county` grain to summarize richness for both groupings. We also tested the strength of this relationship by running a correlation test with the Pearson product-moment correlation (species type richness by species richness). 
```{r generate sr and str, echo = FALSE}
#Authors: NGS, TT, LC, NAH

#generate SR per county
srPerCounty <- over(aqua_invasives_spatial, county)
srPerCounty <- cbind(srPerCounty, aqua_invasives_spatial$state_scientific_name)
colnames(srPerCounty)[colnames(srPerCounty) %in% 'aqua_invasives_spatial$state_scientific_name'] <- 'species' 
srPerCounty <- group_by(srPerCounty, COUNTY_NAM) 
srPerCounty <- dplyr::summarise(srPerCounty, sr=length(unique(species)))

#generate species type richness per county
srPerType <- over(aqua_invasives_spatial, county)
srPerType <- cbind(srPerType, aqua_invasives_spatial$speciestype)
colnames(srPerType)[colnames(srPerType) %in% 'aqua_invasives_spatial$speciestype'] <- 'speciestype' 
srPerType <- group_by(srPerType, COUNTY_NAM) 
srPerType <- dplyr::summarise(srPerType, sr=length(unique(speciestype)))

#join the two by county
sr_str <- inner_join(srPerType, srPerCounty, by = "COUNTY_NAM", suffix = c(".species_type", ".species"))
knitr::kable(sr_str, col.names = c("County", "Species Richness", "Species Type Richness"))

#test correlation between STR and SR
cor.test(sr_str$sr.species_type,sr_str$sr.species)

#plot the data
ggplot(data = sr_str, mapping = aes(x = sr.species_type, y = sr.species)) +
  geom_point(position = position_jitter(h = 0.25, w = 0.25)) +
  geom_smooth(method = "lm") +
  ggtitle("Covariation Between Aquatic Species Type Richness And Species Richness\nPer Pennsylvania County") +
  labs(x = "Species Type Richness", y = "Species Richness")
```

It seems that there is a significant positive correlation between aquatic species richness per county and aquatic species type richness per county. This relationship is expected if there are not too many strong biases towards observations of certain groups or individual species. Nevertheless, a visual inspection of the relationship does suggest that the data cluster around certain species type richness values, indicating that some limits may exist (species richness per species group) that are influencing the data.