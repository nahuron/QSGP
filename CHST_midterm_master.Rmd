---
title: 'Aquatic Invasive Species of Pennsylvania: NEED TO CHANGE TITLE'
date: "3/22/2018"
author: Lisa Chemplayil, Nicholas Huron, Nicolina Sciarretta, Tom Thomas
output: 
  html_document:
    toc: true
    toc_depth: 3
---

##Abstract
TEXT NEEDS TO GO HERE (~50-100 word abstract that describes your findings on Pennsylvaniaâ€™s Invasive Species Problem to a general audience.)

```{r setup, results='hide', message=FALSE, echo = FALSE}
#Authors: TT, NGS, NAH

#clear workspace first
rm(list=ls())

knitr::opts_chunk$set(echo = TRUE)
#set the directory
knitr::opts_knit$set(root.dir = "/Volumes/GoogleDrive/My Drive")
#For PCs
#knitr::opts_knit$set(root.dir = "G:/My Drive/")
#for NAH ubuntu
#knitr::opts_knit$set(root.dir = "/home/nicholas/QSGP/")

#load required packages
library(tidyverse)
library(ggmap)
library(RColorBrewer)
library(sp)
library(raster)
library(rgdal)
library(maptools)

#set working directory as needed if the root.dir call fails
#For mac
#setwd("/Volumes/GoogleDrive/My Drive/")
#For PCs
#setwd("G:/My Drive/")
```

##I. Wrangle Invasive Species Records And PA Spatial Data
###Load Data

An initial clean up available invasive and Pennsylvania (PA) spatial datasets was performed after obtaining both datasets. The invasive records (`invasives`) were obtained from the *Pennsylvania iMapInvasives* program ([website](https://www.paimapinvasives.org/)). While all shapefiles (PA spatial data) were loaded, we focused on the 18 **federal congressional districts** as drawn from the 2010 US Census data (`congress`). 

```{r read data, results='hide', message=FALSE, echo = FALSE}
#Authors: TT, NGS, NAH

#Read in invasives dataset and polygon shapefiles

#read in invasives
invasives <- read_csv("./QuantSci_GP/data/PA_Invasive_Species/all_obs_imap_18Dec17_v2_0.csv", progress = FALSE)

#read in shapefiles
town      <-readOGR(dsn = "./QuantSci_GP/data/PA_Invasive_Species/shapefiles", layer='PaMunicipalities2017_01')
s_senate  <- readOGR(dsn = "./QuantSci_GP/data/PA_Invasive_Species/shapefiles", layer='PaSenatorial2017_01')
s_house   <- readOGR(dsn = "./QuantSci_GP/data/PA_Invasive_Species/shapefiles", layer='PaHouse2017_01')
congress  <- readOGR(dsn = "./QuantSci_GP/data/PA_Invasive_Species/shapefiles", layer='PaCongressional2017_01')
county    <- readOGR(dsn = "./QuantSci_GP/data/PA_Invasive_Species/shapefiles", layer='PaCounty2017_01')
```

###Clean Up Data i: Consistent References

Prior to  analyses, we investigated the content of each dataset.

The focal SpatialPolygonsDataFrame object, `congress`, contains information on the 18 districts. The `data` section contains the following columns that are relevant for our analyses:

  1. LEG_DISTRI [factor]: the unique number identifier for each district
  5. PARTY  [factor]: the one letter code for the political party of each district's representative
  
This object also contains a `polygons` section that gives spatial data that helps draw each district. The `ID` identifies each polygon to a district (although it starts counting at zero and connects through the `plotOrder` section). There is also a `bbox` section that defines the plot area and a `proj4string` section that contains the coordinate reference system to translate latitude and longitude values to the plot.

###(INSERT MORE ON DATASETS HERE, INCLUDING INVASIVES!!!)

Dataset evaluation indicated a need for clean up before inferring invasive species results for PA. This involved changing naming convention of some sections (e.g., changing `obsorigxcoord` to `long` for longitude) and ensuring that a consistent *coordinate reference system* (**CRS**) was in place across all datasets.
```{r rename latlong, echo = FALSE, results = 'hide'}
#Authors: TT

colnames(invasives)[colnames(invasives) %in% 'obsorigxcoord'] <- 'long'
colnames(invasives)[colnames(invasives) %in% 'obsorigycoord'] <- 'lat'
```

```{r standardize shapefile CRS, echo = FALSE, results = 'hide'}
#Authors: TT

#standardize the coordinate reference systems for shapefiles.
county <- spTransform(county, CRS('+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0'))
s_senate <- spTransform(s_senate, CRS('+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0'))
congress <- spTransform(congress, CRS('+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0'))
town <- spTransform(town, CRS('+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0'))
s_house <- spTransform(s_house, CRS('+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0'))
```

###Clean Up Data ii: The Spotted Lanternfly

In our communication with colleagues, we learned that the spotted lanternfly (*Lycorma delicatula*) is not tracked reliably in `invasives`.

First, we summarized the data that have common names containing the word `"fly"`, just to make sure nothing was lost in syntax variation.
```{r EDA lantern fly, echo = FALSE}
#Authors: NAH

invasives %>%
  group_by(state_scientific_name, stateCommonName) %>%
  count() %>%
  filter(str_detect(stateCommonName, pattern = "fly")) %>%
  arrange(desc(n)) %>%
  knitr::kable(., col.names = c("Scientific Name", "Common Name", "Number of Observations"))
```

>It is clear that there are a few observations with fly, and it looks like `"Spotted Lanternfly"` is the consistent common name for this species, but we stuck to the scientific name to be certain when we `filter`ed it out in our new `invasives` object (called `invasives2`).

We then removed all observations matching *Lycorma delicatula*, which resulted in the removal of the **6 observations**, leaving us with 9815 total observations.
```{r filter lanternfly, echo = FALSE, results = 'hide'}
#Authors: TT, NAH

#get original row count
nrow(invasives)

invasives2 <- invasives %>%
  filter(state_scientific_name != "Lycorma delicatula")

#check that we lost some rows
nrow(invasives2)
```

###Clean Up Data iii: Reliable Observation Years

We know from previous communications with the *Pennsylvania iMapInvasives* program that the date of observation (`obsdate`) variable contains data that are not all reliable. To be certain that we use dates with reliable years only, we cleaned `obsdate` and then `mutate`ed a new variable (called `year`) that was used for temporal analyses.
```{r clean obsdate, echo = FALSE, results = 'hide'}
#Authors: NAH

#explore obsdate and obscomments_long
invasives2 %>%
  dplyr::select(obsdate, obscomments_long) %>%
  filter(str_detect(obscomments_long, pattern = "(d|D)ate")) %>%
  arrange(obscomments_long)

#get number of rows of interest
invasives2 %>%
  dplyr::select(obsdate, obscomments_long) %>%
  filter(str_detect(obscomments_long, pattern = "(d|D)ate")) %>%
  arrange(obscomments_long) %>%
  nrow()
```

We confirmed that there are 724 rows that contain some reference to the date in the comments section. These likely represent dates that need fixing or removal from the dataset. To locate the true unknowns/uncertains, we first used the keywords `"unknown"` and `"placeholder"`/`"place-holder"`.
```{r find unknowns, echo = FALSE, results = 'hide'}
#Authors: NAH

invasives2 %>%
  dplyr::select(obsid, obscomments_long) %>%
  filter(str_detect(obscomments_long, pattern = "(d|D)ate")) %>%
  filter(str_detect(obscomments_long, pattern = "(u|U)nknown | (p|P)lace[\\-holder]*")) %>%
  arrange(obscomments_long)
```

Of the 724 rows, only **56** had the keywords we are worried about. These rows represent dates that may be slated for removal. The other 668 are likely ambiguous but could be determined to year with confidence. We trimmed the former before verifying the years for `obsdate` values in the latter. We then used `obsid` values as our identifiers for the rows we needed to remove (manually spot-checked the 56 rows).
```{r rm questionable date rows, echo = FALSE, results = 'hide'}
#Authors: NAH

#check the nrows of invasives2 to start
nrow(invasives2)

#object of rows to remove with certainty
rows2rm <- c("PA-6898U", "PA-379U", "PA-8018U", "PA-6643U", "PA-6407U", "PA-6885U",	"PA-6766U", "PA-6891U", "PA-6693U",	"PA-6761U")

#remove these rows from invasives2
invasives2 <- invasives2 %>%
  dplyr::filter(!(obsid %in% rows2rm))

#check that rows were dropped
nrow(invasives2)
```

As it turned out, only 10 of the rows in the 56 lacked a confident year of observation, so we removed them, resulting in 9805 observations. 

However, this was not the end of cleaning `invasives` by `obsdate`. Using `View()` of `invasivescheck` below, we checked that dates are correct in the table by searching for keywords for unreliable daates by eye. In the `obscomments_long` column, the word *representative* was searched, which resulted in 110 entries. Of those 110 entries about half are dated in `obsdate` as 1980. However, in `obscomments_long`, it states that `"1980 is a repesentative of the time frame (1980-2007) when this county was known to begin hosting HWA"`, indicating a clear problem of reliable **year**. The next word searched was *unknown*, which produced 31 entries, 13 of which conclude that the exact day/month is not known but the year is. The last search word was *known*, this also brought up *unknown* again. *known* had 218 entries, 50 of which referred to the "representative" word, and more than half indicate unknown day/month but known year.
```{r check years, eval = FALSE, echo = FALSE, results = 'hide'}
#Authors: NGS

View(invasivescheck <- invasives2 %>% dplyr::mutate(year = str_extract(obsdate, "\\d{4}")) %>% 
  dplyr::select(obsid, stateCommonName, obsdate, obscomments_long, year))

```

According to these observations the years do match the comments, but the aforementioned `1980-2007` dates required removal. This whittled down `invasives2` to **9756** observations.
```{r remove representative, echo = FALSE, results = 'hide'}
#Authors: NAH

#filter out the observations with the 1980-2007 date range. This can be done with a match of "representative", but when observing the filtration of View(), there are some other unintended rows that are fine for dates. Instead, let's filter with that date range in the comments, "1980-2007" as well!
(rows2rm2 <- invasives2 %>%
  dplyr::select(obsid, obscomments_long) %>%
  filter(str_detect(obscomments_long, pattern = "(r|R)epresentative")) %>%
  filter(str_detect(obscomments_long, pattern = "1980\\-2007")) %>%
  arrange(obscomments_long) %>%
  dplyr::select(obsid))

rows2rm2 <- as_vector(rows2rm2)

#invasives2 row check
nrow(invasives2)

#remove these rows from invasives2
invasives2 <- invasives2 %>%
  dplyr::filter(!(obsid %in% rows2rm2))

#final row check in invasives2
nrow(invasives2)

```

We then created the new `year` column for temporal analyses, thereby resolving `obsdate` inconsistencies and permitting us to begin exploring the data.
```{r mutate years, echo = FALSE, results = 'hide'}
#Authors: NAH

invasives2 %>%
  dplyr::mutate(year = str_extract(obsdate, "\\d{4}"))
```


##II. EDA - Univariate  
###Identify focal species

First, we read in the `iMap_spp.csv` file to a new object `imap_spp`. We can trim the new object down to all entries we already tidied by selectively joining `imap_spp` to `invasives2` by `"state_scientific_name", "stateCommonName", and "natlhabitat"`. The resulting object is `invasives3`. 
```{r read in imap_spp and join}
#Authors: NAH

#read in imap_spp
imap_spp <- read_csv("./QuantSci_GP/data/PA_Invasive_Species/iMap_sppp.csv")
#change the colname to match invasives2
colnames(imap_spp)[colnames(imap_spp) %in% "SpeciesType"] <- "speciestype"

#left join to invasives2 to make new object, invasives3
invasives3 <- left_join(x = invasives2, y = imap_spp, by = c("state_scientific_name", "stateCommonName", "natlhabitat"))

#now we need to drop the invasives2 version of speciestype and rename speciestype.y to speciestype
invasives3 <- invasives3 %>%
  dplyr::select(-speciestype.x, speciestype = speciestype.y)

invasives3

```

Now, data exploration can be done to select focal taxa. Full disclosure, an exploration of this summary was done previously, leading to the use of aquatic species, as they are taxonomically diverse and less biased towards overwhelming plant observations. The final filtered version of just **aquatic invasive species** is called `aqua_invasives`.
```{r look at aquatic v terrestrial and then filter}
#Authors: NAH
imap_spp %>%
  #filter(state_scientific_name %in% as_vector((invasives3 %>% distinct(state_scientific_name)))) %>%
  filter(state_scientific_name %in% unique(invasives3$state_scientific_name)) %>%
  group_by(natlhabitat) %>%
  count()
imap_spp %>%
  filter(state_scientific_name %in% unique(invasives3$state_scientific_name)) %>%
  group_by(natlhabitat, speciestype) %>%
  count() %>%
  arrange(desc(n))

#filter for natlhabitat == "aquatic"
(aqua_invasives <- invasives3 %>%
  filter(natlhabitat == "aquatic" | natlhabitat == "Aquatic"))

```

>It is easy to see that working with aquatic species may involve fewer species, but the involved species are separated by group more evenly (not 201 of 209 as plants, as in terrestrial species).


We also need to make the `aqua_invasives` object a SpatialPolygonsDataFrame and set the CRS for that as well, now that we have tidied it. To make this easier, we will create a new object, `aqua_invasives_spatial`. This way, we can always reference the original tibble.
```{r convert invasives}
#Authors: TT, NAH
aqua_invasives_spatial <- aqua_invasives

coordinates(aqua_invasives_spatial) <- ~long+lat
proj4string(aqua_invasives_spatial) <- projection('+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0')
```
  


###Species Richeness Per Federal Congressional
```{r join SR and congressional data}
#Authors: NGS
srPerCongressional <- over(aqua_invasives_spatial, congress)
srPerCongressional <- cbind(srPerCongressional, aqua_invasives_spatial$state_scientific_name)
colnames(srPerCongressional)[colnames(srPerCongressional) %in% 'aqua_invasives_spatial$state_scientific_name'] <- 'species' 
srPerCongressional <- group_by(srPerCongressional, LEG_DISTRI) 
srPerCongressional <- dplyr::summarise(srPerCongressional, sr=length(unique(species)))
```

```{r plot the results, message = FALSE} 
#Authors: NGS
invasivesCongressional <- congress
invasivesCongressional@data <- left_join(invasivesCongressional@data, srPerCongressional, by='LEG_DISTRI') 

#fix the data type of for R.linux (this snippet by NAH)
if(Sys.info()["sysname"]=="Linux"){
  invasivesCongressional@data$LEG_DISTRI <- as.character(invasivesCongressional@data$LEG_DISTRI)
}

invasivesCongressionalgg <- fortify(invasivesCongressional, region='LEG_DISTRI') 
invasivesCongressionalgg <- left_join(invasivesCongressionalgg, invasivesCongressional@data, by=c('id' = "LEG_DISTRI")) 

p <- ggplot(data=invasivesCongressionalgg)+
  geom_polygon(aes(x=long, y=lat, group=group, fill=sr))+ 
  coord_fixed(1.3)+ 
  scale_fill_gradient() +
  ggtitle(str_to_title("Species Richness of Invasive Aquatic Species In Pennsylvania")) +
    labs(y = "Latitude of PA in Degrees", x = "Longitute of PA in Degrees")

p
```

Now, we can break down aquatic invasive species richness by congression LEG_DISTRI for the five major species types in the dataset:
```{r split by species type}
#Authors: NGS, NAH
turtles <- aqua_invasives %>% filter(speciestype == "turtle")
plants <- aqua_invasives %>% filter(speciestype == "plant")
arthropods <- aqua_invasives %>% filter(speciestype == "arthropod")
mollusc <- aqua_invasives %>% filter(speciestype == "mollusc")
fish <- aqua_invasives %>% filter(speciestype == "fish")

#combine into a list for easy looping
byspeciestype <- list(turtles, plants, arthropods, mollusc, fish)
names(byspeciestype) <- c("turtles", "plants", "arthropods", "mollusc", "fish")
```

Now that we have filtered versions of `aqua_invasives` for each `speciestype`, so we need to turn them into **SpatialPolygonsDataFrames** and calculate **Species Richness (SR)**. In summarizing the **SR** for each `speciestype`, we need to populate counties that are missing in the output with **SR** set to zero. This is done mid-loop, check the code comments for further details.

```{r loop get SR by LEG_DISTRI, message = FALSE}
#Authors: NGS, NAH
#create new version of list that contains each species type
spatial_byspeciestype <- byspeciestype

#loop to set the coordinate system and reference system
for(a in seq_along(spatial_byspeciestype)){
  coordinates(spatial_byspeciestype[[a]]) <- ~long+lat
  proj4string(spatial_byspeciestype[[a]]) <- projection('+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0')
}

#next, we need to perform a similar loop to overlay the spatial invasives data with the congressional LEG_DISTRI data. we will also end up summarising SR by LEG_DISTRI for each group in this loop.

#initialize holder lists for loops  
sr_per_congressional_byspeciestype <- spatial_byspeciestype
invasive_congressional_byspeciestype <- spatial_byspeciestype
invasive_congressional_gg_byspeciestype <- spatial_byspeciestype
  
for(b in seq_along(spatial_byspeciestype)){
  sr_per_congressional_byspeciestype[[b]] <- over(spatial_byspeciestype[[b]], congress)
  sr_per_congressional_byspeciestype[[b]] <- cbind(sr_per_congressional_byspeciestype[[b]], spatial_byspeciestype[[b]]$state_scientific_name)
  colnames(sr_per_congressional_byspeciestype[[b]])[colnames(sr_per_congressional_byspeciestype[[b]]) %in% 'spatial_byspeciestype[[b]]$state_scientific_name'] <- 'species'
  sr_per_congressional_byspeciestype[[b]] <- group_by(sr_per_congressional_byspeciestype[[b]], LEG_DISTRI)
  sr_per_congressional_byspeciestype[[b]] <- dplyr::summarise(sr_per_congressional_byspeciestype[[b]], sr=length(unique(species))) %>% 
    filter(!is.na(LEG_DISTRI))
  
#we need to add code here that adds the missing districts with SR==0
if(length(setdiff(congress$LEG_DISTRI, sr_per_congressional_byspeciestype[[b]]$LEG_DISTRI)) > 0){
sr_per_congressional_byspeciestype[[b]] <- add_row(sr_per_congressional_byspeciestype[[b]], LEG_DISTRI = setdiff(congress$LEG_DISTRI, sr_per_congressional_byspeciestype[[b]]$LEG_DISTRI), sr = rep(0, length(setdiff(congress$LEG_DISTRI, sr_per_congressional_byspeciestype[[b]]$LEG_DISTRI))))
}
  
  invasive_congressional_byspeciestype[[b]] <- congress
  invasive_congressional_byspeciestype[[b]]@data <- left_join(invasive_congressional_byspeciestype[[b]]@data, sr_per_congressional_byspeciestype[[b]], by = "LEG_DISTRI")
  
#fix the data type of for R.linux (this snippet by NAH)
if(Sys.info()["sysname"]=="Linux"){
  invasive_congressional_byspeciestype[[b]]@data$LEG_DISTRI <- as.character(invasive_congressional_byspeciestype[[b]]@data$LEG_DISTRI)
}

  invasive_congressional_gg_byspeciestype[[b]] <- fortify(invasive_congressional_byspeciestype[[b]], sr_per_congressional_byspeciestype[[b]], region = 'LEG_DISTRI')
  invasive_congressional_gg_byspeciestype[[b]] <- left_join(invasive_congressional_gg_byspeciestype[[b]], invasive_congressional_byspeciestype[[b]]@data, by = c("id" = 'LEG_DISTRI'))
}

```

Now we have the object `invasive_congressional_gg_byspeciestype` that is formatted to plot the map of results for each species

```{r loop to plot by group} 
#Authors: NGS, NAH
#loop through ggplot commands
for(c in seq_along(invasive_congressional_gg_byspeciestype)){
   print(
    ggplot(data = invasive_congressional_gg_byspeciestype[[c]]) +
    geom_polygon(aes(x=long, y=lat, group=group, fill=sr))+ 
    coord_fixed(1.3)+ 
    scale_fill_gradient()+
    ggtitle(str_to_title(paste0("Species Richness of Invasive Aquatic ", names(invasive_congressional_gg_byspeciestype)[c], " in Pennsylvania"))) +
    labs(y = "Latitude of PA in Degrees", x = "Longitute of PA in Degrees")
   )
}

```

###Univariate Distributions of richness for each grain and group

To compare species richness between grains, we need to develop a version of the code for `congress` and `aqua_invasives` for all other grain types. Before we do that, let's show we can plot the univariate curve of SR for congress

```{r plot sr curve congress}
#Authors: NAH
ggplot(data = srPerCongressional) +
  geom_density(aes(sr), fill = "black") +
  ggtitle(str_to_title(paste0("Species Richness of Invasive Aquatic Species"))) +
  labs(y = "Density", x = "sr")
```

Let's create a list with the SR for all grains:
```{r get SR per grain}
#Authors: NAH

#town    MUNICPAL_
#s_senate LEG_DISTRI
#s_house LEG_DISTRI
#congress LEG_DISTRI
#county  COUNTY_NAM

#initialize a bunch of lists to hold  results
sr_per_grain <- list(NULL, NULL, NULL, NULL, NULL)
grains <- list(town, s_senate, s_house, congress, county)
names(grains) <- c("town", "s_senate", "s_house", "congress", "county")
names(sr_per_grain) <- names(grains)


#we can loop for the three grains with LEG_DISTRI (We will need to manual entry for the other two after that)
for(d in seq_along(sr_per_grain)[2:4]){
  sr_per_grain[[d]] <- over(aqua_invasives_spatial, grains[[d]])
  sr_per_grain[[d]] <- cbind(sr_per_grain[[d]], aqua_invasives_spatial$state_scientific_name)
  colnames(sr_per_grain[[d]])[colnames(sr_per_grain[[d]]) %in% 'aqua_invasives_spatial$state_scientific_name'] <- 'species'
  sr_per_grain[[d]] <- group_by(sr_per_grain[[d]], LEG_DISTRI)
  sr_per_grain[[d]] <- dplyr::summarise(sr_per_grain[[d]], sr=length(unique(species)))
}

#manual for town
  sr_per_grain[[1]] <- over(aqua_invasives_spatial, grains[[1]])
  sr_per_grain[[1]] <- cbind(sr_per_grain[[1]], aqua_invasives_spatial$state_scientific_name)
  colnames(sr_per_grain[[1]])[colnames(sr_per_grain[[1]]) %in% 'aqua_invasives_spatial$state_scientific_name'] <- 'species'
  sr_per_grain[[1]] <- group_by(sr_per_grain[[1]], MUNICIPAL_)
  sr_per_grain[[1]] <- dplyr::summarise(sr_per_grain[[1]], sr=length(unique(species)))

#manual for county
  sr_per_grain[[5]] <- over(aqua_invasives_spatial, grains[[5]])
  sr_per_grain[[5]] <- cbind(sr_per_grain[[5]], aqua_invasives_spatial$state_scientific_name)
  colnames(sr_per_grain[[5]])[colnames(sr_per_grain[[5]]) %in% 'aqua_invasives_spatial$state_scientific_name'] <- 'species'
  sr_per_grain[[5]] <- group_by(sr_per_grain[[5]], COUNTY_NUM)
  sr_per_grain[[5]] <- dplyr::summarise(sr_per_grain[[5]], sr=length(unique(species)))
  
```

Now, we visualize the distribution of SR for each grain.
```{r plot sr curve grains}
#Authors: NAH

#plot the curves together
ggplot() +
  geom_density(data = sr_per_grain[[1]], aes(sr, fill = names(sr_per_grain)[1]), alpha = 0.5) +
  geom_density(data = sr_per_grain[[2]], aes(sr, fill = names(sr_per_grain)[2]), alpha = 0.5) +
  geom_density(data = sr_per_grain[[3]], aes(sr, fill = names(sr_per_grain)[3]), alpha = 0.5) +
  geom_density(data = sr_per_grain[[4]], aes(sr, fill = names(sr_per_grain)[4]), alpha = 0.5) +
  geom_density(data = sr_per_grain[[5]], aes(sr, fill = names(sr_per_grain)[5]), alpha = 0.5) +
  ggtitle(str_to_title(paste0("Species Richness Of Invasive Aquatic Species By Grain"))) +
  labs(y = "Density", x = "sr") +
  scale_fill_manual(name = "Grain", values = c("red", "blue", "green", "orange", "black"), labels = c("congress", "county", "s_house", "s_senate", "town"), guide = 'legend')
```

In looking at each of the grains, it is clear that there are differences in SR by grain. While the means of the distributions appear to cluster around 0-10 (estimated visually), none overlap perfectly. Some appear shifted slightly relative to the rest (e.g., congress is shifted right of state house).

Let's repeat the process for different `speciestype`s for the `congress` grain. Note that the object `sr_per_congressional_byspeciestype` contains all of the data we need to make the comparison! We simply need to create a similar plot to the one for grains above.
```{r plot SR per speciestype in congress}
#Authors: NAH

#plot the curves together
ggplot() +
  geom_density(data = sr_per_congressional_byspeciestype[[1]], aes(sr, fill = names(sr_per_congressional_byspeciestype)[1]), alpha = 0.5) +
  geom_density(data = sr_per_congressional_byspeciestype[[2]], aes(sr, fill = names(sr_per_congressional_byspeciestype)[2]), alpha = 0.5) +
  geom_density(data = sr_per_congressional_byspeciestype[[3]], aes(sr, fill = names(sr_per_congressional_byspeciestype)[3]), alpha = 0.5) +
  geom_density(data = sr_per_congressional_byspeciestype[[4]], aes(sr, fill = names(sr_per_congressional_byspeciestype)[4]), alpha = 0.5) +
  geom_density(data = sr_per_congressional_byspeciestype[[5]], aes(sr, fill = names(sr_per_congressional_byspeciestype)[5]), alpha = 0.5) +
  ggtitle(str_to_title(paste0("Species Richness Of Invasive Aquatic Species By Species Type"))) +
  labs(y = "Density", x = "sr") +
  scale_fill_manual(name = "Species Type", values = c("red", "blue", "green", "orange", "black"), labels = c("arthropods", "fish", "mollusc", "plants", "turtles"), guide = 'legend')
  
```

Looking among species types, we do see several groups that almost approximate normal distributions (namely plants and mollusc). The rest appear to be multimodal, with some cases of `SR == 0` and at least one case of `SR > 0`. Notably, the two `speciestype`s that are closest to normal distribution shape also have the highest instances of species richness.

For both `grain` and `speciestype`, it is clear that distributions are not exactly normal, so it is worth exploring data transformation. In an effort to normalize these data, let's try a **log** transformation first, since it will tighten some of the wider distributions. Since we have values of `0`, adding `1` to each `SR` value is necessary before transformation.

```{r plot log transform grains}
#Authors: NAH
ggplot() +
  geom_density(data = sr_per_grain[[1]], aes(log(sr+1), fill = names(sr_per_grain)[1]), alpha = 0.5) +
  geom_density(data = sr_per_grain[[2]], aes(log(sr+1), fill = names(sr_per_grain)[2]), alpha = 0.5) +
  geom_density(data = sr_per_grain[[3]], aes(log(sr+1), fill = names(sr_per_grain)[3]), alpha = 0.5) +
  geom_density(data = sr_per_grain[[4]], aes(log(sr+1), fill = names(sr_per_grain)[4]), alpha = 0.5) +
  geom_density(data = sr_per_grain[[5]], aes(log(sr+1), fill = names(sr_per_grain)[5]), alpha = 0.5) +
  ggtitle(str_to_title(paste0("Species Richness Of Invasive Aquatic Species By Grain"))) +
  labs(y = "Density", x = "ln(sr+1)") +
  scale_fill_manual(name = "Grain", values = c("red", "blue", "green", "orange", "black"), labels = c("congress", "county", "s_house", "s_senate", "town"), guide = 'legend')
```

```{r plot log transform speciestype}
#Authors: NAH
ggplot() +
  geom_density(data = sr_per_congressional_byspeciestype[[1]], aes(log(sr+1), fill = names(sr_per_congressional_byspeciestype)[1]), alpha = 0.5) +
  geom_density(data = sr_per_congressional_byspeciestype[[2]], aes(log(sr+1), fill = names(sr_per_congressional_byspeciestype)[2]), alpha = 0.5) +
  geom_density(data = sr_per_congressional_byspeciestype[[3]], aes(log(sr+1), fill = names(sr_per_congressional_byspeciestype)[3]), alpha = 0.5) +
  geom_density(data = sr_per_congressional_byspeciestype[[4]], aes(log(sr+1), fill = names(sr_per_congressional_byspeciestype)[4]), alpha = 0.5) +
  geom_density(data = sr_per_congressional_byspeciestype[[5]], aes(log(sr+1), fill = names(sr_per_congressional_byspeciestype)[5]), alpha = 0.5) +
  ggtitle(str_to_title(paste0("Species Richness Of Invasive Aquatic Species By Species Type"))) +
  labs(y = "Density", x = "ln(sr+1)") +
  scale_fill_manual(name = "Species Type", values = c("red", "blue", "green", "orange", "black"), labels = c("arthropods", "fish", "mollusc", "plants", "turtles"), guide = 'legend')

```

Looking among species types, we do see several groups that almost approximate normal distributions (namely plants and mollusc). The rest appear to be multimodal, with some cases of `SR == 0` and at least one case of `SR > 0`. Notably, the two `speciestype`s that are closest to normal distribution shape also have the highest instances of species richness.

In both cases, it does appear like normality may be improved somewhat. A Shapiro-Wilk Normality Test can help evaluation between untransformed and transformed data. With a loop, it is easy enough to produce a before/after table:

```{r shapiro tests}
#Authors: NAH
swtest_grains <- tibble(untransformed.w = NA, logtransformed.w = NA, untransformed.p = NA, logtransformed.p = NA)
for(e in seq_along(sr_per_grain)){
  compare_holder <- c(NA, NA, NA, NA)
  names(compare_holder) <- c("untransformed.w", "logtransformed.w", "untransformed.p", "logtransformed.p")
  compare_holder[1] <- shapiro.test(sr_per_grain[[e]]$sr)$statistic
  compare_holder[2] <- shapiro.test(log((sr_per_grain[[e]]$sr+1)))$statistic
  compare_holder[3] <- shapiro.test(sr_per_grain[[e]]$sr)$p.value
  compare_holder[4] <- shapiro.test(log((sr_per_grain[[e]]$sr+1)))$p.value
  swtest_grains <- bind_rows(swtest_grains, compare_holder)
swtest_grains <- swtest_grains %>% filter(complete.cases(.))
}

(swtest_grains)

swtest_speciestype <- tibble(untransformed.w = NA, logtransformed.w = NA, untransformed.p = NA, logtransformed.p = NA)
for(e in seq_along(sr_per_congressional_byspeciestype)){
  compare_holder <- c(NA, NA, NA, NA)
  names(compare_holder) <- c("untransformed.w", "logtransformed.w", "untransformed.p", "logtransformed.p")
  compare_holder[1] <- shapiro.test(sr_per_congressional_byspeciestype[[e]]$sr)$statistic
  compare_holder[2] <- shapiro.test(log((sr_per_congressional_byspeciestype[[e]]$sr+1)))$statistic
  compare_holder[3] <- shapiro.test(sr_per_congressional_byspeciestype[[e]]$sr)$p.value
  compare_holder[4] <- shapiro.test(log((sr_per_congressional_byspeciestype[[e]]$sr+1)))$p.value
  swtest_speciestype <- bind_rows(swtest_speciestype, compare_holder)
swtest_speciestype <- swtest_speciestype %>% filter(complete.cases(.))
}

(swtest_speciestype)
```

